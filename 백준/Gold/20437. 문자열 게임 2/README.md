# [Gold V] 문자열 게임 2 - 20437 

[문제 링크](https://www.acmicpc.net/problem/20437) 

### 성능 요약

메모리: 33432 KB, 시간: 596 ms

### 분류

문자열, 슬라이딩 윈도우

### 제출 일자

2025년 7월 13일 01:02:04

### 문제 설명

<p>작년에 이어 새로운 문자열 게임이 있다. 게임의 진행 방식은 아래와 같다.</p>

<ol>
	<li>알파벳 소문자로 이루어진 문자열 W가 주어진다.</li>
	<li>양의 정수 K가 주어진다.</li>
	<li>어떤 문자를 정확히 K개를 포함하는 가장 짧은 연속 문자열의 길이를 구한다.</li>
	<li>어떤 문자를 정확히 K개를 포함하고, 문자열의 첫 번째와 마지막 글자가 해당 문자로 같은 가장 긴 연속 문자열의 길이를 구한다.</li>
</ol>

<p>위와 같은 방식으로 게임을 T회 진행한다.</p>

### 입력 

 <p>문자열 게임의 수 T가 주어진다. (1 ≤ T ≤ 100)</p>

<p>다음 줄부터 2개의 줄 동안 문자열 W와 정수 K가 주어진다. (1 ≤ K ≤ |W| ≤ 10,000) </p>

### 출력 

 <p>T개의 줄 동안 문자열 게임의 3번과 4번에서 구한 연속 문자열의 길이를 공백을 사이에 두고 출력한다.</p>

<p>만약 만족하는 연속 문자열이 없을 시 -1을 출력한다.</p>

# 회고

처음으로 든 아이디어에서 사용할 수 있는 자료구조는 슬라이싱, 스택, 딕셔너리가 떠올랐다. 하지만 2중 for문으로 무조건 돌리면 100개의 케이스의 문자열 10000개라면 시간초과 우려가 있었다. 먼저 딕셔너리의 특성을 이용해 문자열의 각 자리 인덱스를 리스트로 추가해주고, 추가된 인덱스의 리스트에서 서로 빼주면 양 쪽이 같은 문자열 중 가장 짧은 수, 긴 수 를 출력하는 원리였다. 단 K개의 문자열을 포함해야 하니 for문의 인덱스 범위계산하는 부분에서 시간이 걸렸다. 결국 K번째의 인덱스까지 포함해야하니까 len(i)-K+1을 지정한 후 계산을 해주었다.
