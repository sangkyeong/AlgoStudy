# [Gold IV] 이차원 배열과 연산 - 17140 

[문제 링크](https://www.acmicpc.net/problem/17140) 

### 성능 요약

메모리: 18988 KB, 시간: 188 ms

### 분류

구현, 정렬, 집합과 맵, 시뮬레이션

### 제출 일자

2025년 7월 9일 00:24:24

### 문제 설명

<p>크기가 3×3인 배열 A가 있다. 배열의 인덱스는 1부터 시작한다. 1초가 지날때마다 배열에 연산이 적용된다.</p>

<ul>
	<li>R 연산: 배열 A의 모든 행에 대해서 정렬을 수행한다. 행의 개수 ≥ 열의 개수인 경우에 적용된다.</li>
	<li>C 연산: 배열 A의 모든 열에 대해서 정렬을 수행한다. 행의 개수 < 열의 개수인 경우에 적용된다.</li>
</ul>

<p>한 행 또는 열에 있는 수를 정렬하려면, 각각의 수가 몇 번 나왔는지 알아야 한다. 그 다음, 수의 등장 횟수가 커지는 순으로, 그러한 것이 여러가지면 수가 커지는 순으로 정렬한다. 그 다음에는 배열 A에 정렬된 결과를 다시 넣어야 한다. 정렬된 결과를 배열에 넣을 때는, 수와 등장 횟수를 모두 넣으며, 순서는 수가 먼저이다.</p>

<p>예를 들어, [3, 1, 1]에는 3이 1번, 1가 2번 등장한다. 따라서, 정렬된 결과는 [3, 1, 1, 2]가 된다. 다시 이 배열에는 3이 1번, 1이 2번, 2가 1번 등장한다. 다시 정렬하면 [2, 1, 3, 1, 1, 2]가 된다.</p>

<p>정렬된 결과를 배열에 다시 넣으면 행 또는 열의 크기가 달라질 수 있다. R 연산이 적용된 경우에는 가장 큰 행을 기준으로 모든 행의 크기가 변하고, C 연산이 적용된 경우에는 가장 큰 열을 기준으로 모든 열의 크기가 변한다. 행 또는 열의 크기가 커진 곳에는 0이 채워진다. 수를 정렬할 때 0은 무시해야 한다. 예를 들어, [3, 2, 0, 0]을 정렬한 결과는 [3, 2]를 정렬한 결과와 같다.</p>

<p>행 또는 열의 크기가 100을 넘어가는 경우에는 처음 100개를 제외한 나머지는 버린다.</p>

<p>배열 A에 들어있는 수와 r, c, k가 주어졌을 때, A[r][c]에 들어있는 값이 k가 되기 위한 최소 시간을 구해보자.</p>

### 입력 

 <p>첫째 줄에 r, c, k가 주어진다. (1 ≤ r, c, k ≤ 100)</p>

<p>둘째 줄부터 3개의 줄에 배열 A에 들어있는 수가 주어진다. 배열 A에 들어있는 수는 100보다 작거나 같은 자연수이다.</p>

### 출력 

 <p>A[r][c]에 들어있는 값이 k가 되기 위한 연산의 최소 시간을 출력한다. 100초가 지나도 A[r][c] = k가 되지 않으면 -1을 출력한다.</p>

 # 회고

문제를 읽고 가변이 된다는 부분에서 배열을 쓸까 ArrayList를 쓸까 고민하다 최대 100개라는 제한이 있어 인덱싱이 빠른 배열을 선택했다. 100개의 2차원 배열을 만든 후 hashMap을 통해 각 탐색할 행, 열에 있는 수와 개수를 파악한 후 sort의 편의성을 위해 ArrayList를 사용했고, 정렬 후 다시 원래 2차원 배열에 다시 값을 넣었다. 값을 넣을 때 0이 아닌 숫자 즉, 실제 유효한 배열의 최대 크기를 구해야 다음 탐색의 행, 열 탐색 방향이 정해지기 때문에 max값을 대입해주었다. 다양한 자료구조를 사용해서 시간초과가 날 것 같았는데 배열 인덱싱 덕분인지 통과할 수 있었다. 구현 아이디어를 코드로 옮기는 과정이 시간이 많이 걸려 아쉬웠다.

